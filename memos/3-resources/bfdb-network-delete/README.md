# BfDb Network Delete Implementation Memo

## Overview

This memo outlines the implementation plan for the `BfNode.delete()` method that
handles deletion of nodes and their relationships, with optional cascade
deletion of orphaned records.

## Dependencies

**Phase 1** can be implemented immediately without dependencies.

**Phases 2-3** depend on the worker queue system (PR #1808) for network delete
operations, as cascade deletion can be long-running and should be processed
asynchronously.

## Problem Statement

Currently, `BfNode.delete()` throws `BfErrorNotImplemented`, which breaks the
automatic relationship methods generated by PR #1769. The
`delete{RelationName}()` methods attempt to call `node.delete()` after unlinking
edges, expecting it to work.

Additionally, the current state leads to:

- Broken relationship deletion methods
- Orphaned edges when nodes are deleted manually
- Dangling references in the graph
- Accumulation of unused data over time

## Proposed Solution

Implement the existing `BfNode.delete()` method to:

1. Delete all edges connected to the node (both as source and target)
2. Delete the node itself from storage
3. Optionally identify and delete orphaned nodes (nodes only connected through
   deleted edges)
4. Return success status

## Worker Queue Integration

Once PR #1808 is complete, network delete operations should be processed through
the worker queue:

### Synchronous vs Asynchronous Operations

1. **Synchronous (immediate)**: Simple single-node deletions with few edges
   (< 10)
2. **Asynchronous (worker queue)**:
   - Any deletion with `deleteOrphans: true`
   - Nodes with many edges (> 10)
   - Batch deletions
   - Any operation that could take > 1 second

### Worker Job Structure

```typescript
interface NetworkDeleteJob {
  type: "network-delete";
  nodeId: BfGid;
  options: DeleteOptions;
  requestedBy: BfGid; // User who initiated
  organizationId: BfGid;
}

interface NetworkDeleteProgress {
  phase: "analyzing" | "deleting-edges" | "deleting-nodes" | "complete";
  nodesAnalyzed: number;
  nodesDeleted: number;
  edgesDeleted: number;
  estimatedTotal?: number;
  warnings: string[];
}
```

## Technical Design

### Core Method Signature

```typescript
// In BfNode class
async delete(options?: DeleteOptions): Promise<boolean> {
  // Implementation
}

interface DeleteOptions {
  deleteOrphans?: boolean;  // Default: false for safety
  preserveNodeIds?: Set<BfGid>;
  skipEdgeCleanup?: boolean; // For cases where edges are already handled
}
```

### Algorithm

1. **Basic Delete (default behavior)**:
   - Find and delete all edges where this node is source or target
   - Delete the node itself using `bfDeleteItem`
   - Return true on success

2. **With Orphan Detection (when `deleteOrphans: true`)**:
   - Track nodes to process and already processed nodes
   - After deleting edges, identify connected nodes
   - Check if connected nodes are orphaned
   - Recursively delete orphaned nodes

3. **Edge Cases**:
   - If `skipEdgeCleanup` is true, skip edge deletion (used by relationship
     methods)
   - Respect `preserveNodeIds` to prevent deletion of critical nodes

### Integration with Relationship Methods

The automatic relationship methods already handle edge cleanup:

```typescript
// From relationshipMethods.ts
async function delete{RelationName}() {
  // 1. Find related node
  const results = await node.queryTargetInstances(...);
  
  // 2. Unlink edges (already implemented)
  await node.unlinkTargetInstances([relatedNode.id], relationName);
  
  // 3. Delete node (needs implementation)
  await relatedNode.delete();  // Currently throws BfErrorNotImplemented
}
```

With the implemented `delete()` method, these will work seamlessly.

## Implementation Details

### Using Existing Patterns

The implementation should follow patterns already established in the codebase:

1. **CurrentViewer**: Use `this.currentViewer` from the instance
2. **Organization ID**: Use `this.metadata.bfOid` from the instance
3. **Edge Querying**: Use the same pattern as `unlinkTargetInstances`:

```typescript
// Pattern from existing unlink methods
const edgeMetadata: Partial<BfEdgeMetadata> = {
  bfOid: this.metadata.bfOid,
  bfSid: this.metadata.bfGid, // For outgoing edges
  bfTid: this.metadata.bfGid, // For incoming edges
  className: BfEdge.name,
};

const edges = await BfEdge.query(this.currentViewer, edgeMetadata);
```

### Performance Considerations

- Use parallel queries with `Promise.all` for edge lookups
- Process nodes in batches if dealing with large graphs
- Consider adding a transaction wrapper for atomicity

### Error Handling

- Log all deletion operations for audit trail
- Handle permission errors gracefully
- Provide rollback capability if needed

## Benefits

1. **Fixes Relationship Methods**: Enables `delete{RelationName}()` to work
   immediately
2. **API Consistency**: Uses existing `node.delete()` pattern instead of new
   function
3. **Data Integrity**: Prevents accumulation of orphaned records
4. **Clean Graph Structure**: Maintains referential integrity
5. **Flexible Deletion**: Options to preserve specific nodes or disable cascade
6. **Incremental Implementation**: Can start with basic delete, add cascade
   later

## Testing Plan

1. **Unit Tests**:
   - Test simple node deletion with edges
   - Test cascade deletion of orphaned nodes
   - Test preservation of non-orphaned nodes
   - Test preserve node list functionality

2. **Integration Tests**:
   - Test with complex graph structures
   - Test concurrent deletions
   - Test permission handling

3. **Edge Cases**:
   - Circular references
   - Self-referencing nodes
   - Large deletion cascades

## Implementation Plan

The implementation is broken down into 3 phases:

1. **[Phase 1: Simple Delete Implementation](./phase-1-basic-delete.md)** -
   **READY NOW**
   - Implement `BfNode.delete()` that only deletes the node itself
   - NO edge cleanup (relies on relationship methods already doing this)
   - NO cascade/network delete
   - Fixes the immediate breakage in relationship methods
   - Can be deployed immediately

2. **[Phase 2: Network Delete with Worker Queue](./phase-2-cascade-delete.md)** -
   **REQUIRES PR #1808**
   - Add full edge cleanup and orphan detection
   - Must use worker queue for all operations
   - Provides complete network delete functionality

3. **[Phase 3: GraphQL Integration](./phase-3-graphql-integration.md)** -
   **REQUIRES PHASE 2**
   - Add GraphQL mutations and UI integration
   - Integrates with worker queue status/progress APIs

## Future Enhancements

1. **Soft Delete Support**: Mark as deleted instead of removing
2. **Batch Operations**: Delete multiple root nodes efficiently
3. **Undo/Restore**: Transaction log for reverting deletions
4. **Configurable Rules**: Per-node-type deletion policies
5. **Performance Optimizations**:
   - Indexed orphan detection
   - Parallel deletion execution
   - Caching of edge queries

## Security Considerations

- Ensure CurrentViewer permissions are checked for all nodes in deletion cascade
- Prevent deletion of system-critical nodes
- Add rate limiting for large cascade operations

## API Examples

### Basic Node Deletion

```typescript
// Simple delete (cleans up edges only)
await node.delete();

// Delete with orphan cleanup
await node.delete({ deleteOrphans: true });

// Delete but preserve certain nodes
await node.delete({
  deleteOrphans: true,
  preserveNodeIds: new Set([criticalNodeId]),
});
```

### Relationship Method Usage

```typescript
// Automatically works once delete() is implemented
await parentNode.deleteChild(); // Deletes child node and edge
await project.deleteOwner(); // Deletes owner relationship
```

### GraphQL Mutation

```graphql
mutation DeleteNode($nodeId: ID!, $deleteOrphans: Boolean) {
  deleteNode(nodeId: $nodeId, deleteOrphans: $deleteOrphans) {
    success
    deletedCount
  }
}
```

## Conclusion

Implementing `BfNode.delete()` will immediately fix the broken relationship
deletion methods and provide a foundation for more advanced deletion strategies.
By following existing patterns and providing a phased rollout, we can deliver
immediate value while building towards a comprehensive solution for graph data
management.

The implementation aligns with the existing codebase architecture and maintains
API consistency, making it a natural extension of the BfNode system rather than
a separate utility function.
