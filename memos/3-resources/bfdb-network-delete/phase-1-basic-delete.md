# Phase 1: Simple Delete Implementation

[← Back to README](./README.md) | [Next Phase →](./phase-2-cascade-delete.md)

**Goal**: Implement a minimal `BfNode.delete()` that ONLY deletes the node
itself, fixing the broken relationship methods immediately.

**Priority**: HIGH - This is blocking the automatic relationship methods feature
and can be deployed TODAY.

## Problem Context

The `delete{RelationName}()` methods generated by PR #1769 are currently broken
because they call `node.delete()` which throws `BfErrorNotImplemented`. These
methods already handle edge cleanup before calling delete, so we just need a
minimal implementation that deletes the node itself.

## Key Design Decision: No Edge Cleanup in Phase 1

Phase 1 will NOT include edge cleanup because:

1. **Relationship methods already handle it** - They call
   `unlinkTargetInstances()` before `delete()`
2. **Avoids complexity** - No need to worry about performance with many edges
3. **No worker queue needed** - Simple, synchronous operation
4. **Can deploy immediately** - Unblocks the relationship methods TODAY

## Implementation Steps

### 1. Update BfNode.delete() Method

Location: `apps/bfDb/classes/BfNode.ts`

Replace the current throwing implementation:

```typescript
async delete(): Promise<boolean> {
  throw new BfErrorNotImplemented("delete");
}
```

With a minimal working implementation:

```typescript
async delete(): Promise<boolean> {
  try {
    // Simply delete the node - no edge cleanup in Phase 1
    await bfDeleteItem(this.metadata.bfOid, this.metadata.bfGid);
    return true;
  } catch (error) {
    logger.error(`Failed to delete node ${this.metadata.bfGid}:`, error);
    throw error;
  }
}
```

That's it! No options, no edge cleanup, no complexity. Just delete the node.

### 2. Why This Works

The relationship methods already handle edges:

```typescript
// From relationshipMethods.ts - this is what's calling our delete()
async function delete{RelationName}() {
  const results = await node.queryTargetInstances(...);
  
  if (results.length > 0) {
    const relatedNode = results[0];
    
    // THIS ALREADY REMOVES THE EDGE!
    await node.unlinkTargetInstances([relatedNode.id], relationName);
    
    // So we just need to delete the node itself
    await relatedNode.delete();
  }
}
```

### 3. Document the Limitation

Add a comment to make the limitation clear:

```typescript
/**
 * Delete this node from the database.
 * 
 * NOTE: Phase 1 implementation - does NOT clean up edges.
 * This is sufficient for relationship methods which handle edges separately.
 * Full network delete with edge cleanup will be added in Phase 2.
 * 
 * @returns true if the node was successfully deleted
 */
async delete(): Promise<boolean> {
  try {
    await bfDeleteItem(this.metadata.bfOid, this.metadata.bfGid);
    return true;
  } catch (error) {
    logger.error(`Failed to delete node ${this.metadata.bfGid}:`, error);
    throw error;
  }
}
```

## Testing Plan

### 1. Unit Test for BfNode.delete()

Create/update `apps/bfDb/classes/__tests__/BfNode.test.ts`:

```typescript
Deno.test("BfNode.delete() removes node", async () => {
  const cv = await createTestViewer();

  // Create a simple node
  const person = await BfPerson.create(cv, { name: "Test Person" });
  const personId = person.id;

  // Delete it
  const result = await person.delete();
  assertEquals(result, true);

  // Verify it's gone
  const deletedPerson = await BfPerson.findByBfGid(cv, personId);
  assertEquals(deletedPerson, null);
});
```

### 2. Integration Test with Relationship Methods

This is the critical test - verify the relationship methods work:

```typescript
Deno.test("deleteAuthor() works with BfNode.delete()", async () => {
  const cv = await createTestViewer();

  // Create book with author
  const book = await BfBook.create(cv, { title: "Test Book" });
  const author = await book.createAuthor({ name: "Test Author" });
  const authorId = author.id;

  // Delete author using relationship method
  await book.deleteAuthor(); // Should NOT throw BfErrorNotImplemented

  // Verify author is deleted
  const deletedAuthor = await BfPerson.findByBfGid(cv, authorId);
  assertEquals(deletedAuthor, null);

  // Verify relationship is gone
  const bookAuthor = await book.findAuthor();
  assertEquals(bookAuthor, null);
});
```

### 3. Document Known Limitation

Test that edges are NOT cleaned up (this is expected in Phase 1):

```typescript
Deno.test("Phase 1: delete() does NOT clean up edges", async () => {
  const cv = await createTestViewer();

  // Create nodes with relationship
  const author = await BfPerson.create(cv, { name: "Test Author" });
  const book = await BfBook.create(cv, { title: "Test Book" });
  const edge = await book.linkAuthor(author);

  // Delete author directly (not through relationship method)
  await author.delete();

  // Node is deleted
  assertEquals(await BfPerson.findByBfGid(cv, author.id), null);

  // But edge still exists (this is the known limitation)
  const orphanedEdge = await BfEdge.findByBfGid(cv, edge.id);
  assertNotEquals(orphanedEdge, null);

  // This is OK for Phase 1 - will be fixed in Phase 2
});
```

## Rollout Strategy

1. **Deploy immediately** - This is a minimal, safe change
2. **Document the limitation** - Make it clear that edges aren't cleaned up
3. **Plan for Phase 2** - Full network delete will come with worker queue

## Success Criteria

- [ ] `BfNode.delete()` successfully deletes nodes
- [ ] All `delete{RelationName}()` methods work without throwing errors
- [ ] Tests pass showing the method works as designed
- [ ] Clear documentation of the edge cleanup limitation

## Known Limitations

1. **Orphaned edges** - If you call `node.delete()` directly (not through a
   relationship method), edges will be orphaned
2. **No cascade delete** - Only the specific node is deleted
3. **No network delete** - Related orphaned nodes are not cleaned up

These limitations are acceptable for Phase 1 because:

- Relationship methods handle their own edge cleanup
- We can deploy immediately without waiting for worker queue
- Phase 2 will add full network delete capabilities

## Next Steps

Once Phase 1 is deployed and stable, proceed to
[Phase 2: Cascade Delete](./phase-2-cascade-delete.md) to add orphan detection
capabilities.
