#!/usr/bin/env -S bft run

import { getConfigurationVariable } from "@bolt-foundry/get-configuration-var";
import type { TaskDefinition } from "../bft.ts";
import { getLogger } from "@bfmono/packages/logger/logger.ts";
import { parseEnvFile } from "@bfmono/packages/env/utils.ts";
import * as yaml from "@std/yaml";
import * as path from "@std/path";

const logger = getLogger(import.meta);

export const bftDefinition = {
  description: "Generate Kamal deploy.yml from sitevars and template",
  fn: generateKamalConfig,
} satisfies TaskDefinition;

async function getSecretValue(key: string): Promise<string | undefined> {
  try {
    const secretsContent = await Deno.readTextFile(".env.secrets");
    const secrets = parseEnvFile(secretsContent);
    return secrets[key];
  } catch {
    return undefined;
  }
}

async function generateKamalConfig(args: Array<string>): Promise<number> {
  try {
    const templatePath = args[0] || "infra/terraform/hetzner/deploy.yml.tpl";
    const outputPath = args[1] || "config/deploy.yml";
    const environment = args[2] || "production";

    logger.info(`Generating Kamal config for ${environment} environment`);

    // Read the template file
    const templateContent = await Deno.readTextFile(templatePath);

    // First replace template variables
    let processedTemplate = templateContent;

    // Get server IP from environment or secrets
    const serverIp = getConfigurationVariable("BOLTFOUNDRY_COM_SERVER_IP") ||
      (await getSecretValue("BOLTFOUNDRY_COM_SERVER_IP"));

    if (serverIp) {
      processedTemplate = processedTemplate.replace(
        /\${floating_ip}/g,
        serverIp,
      );
    }

    // Replace other template variables with defaults
    processedTemplate = processedTemplate
      .replace(/\${github_username}/g, "bolt-foundry")
      .replace(/\${domain}/g, "boltfoundry.com");

    // Parse template as YAML to preserve structure
    // Define a proper type for the Kamal config
    interface KamalConfig {
      env?: {
        clear?: Record<string, unknown>;
        secret?: string[];
      };
      [key: string]: unknown;
    }

    const config = yaml.parse(processedTemplate) as KamalConfig;

    // Read available secrets from .env.secrets
    const secretsPath = ".env.secrets";
    let availableSecrets: Array<string> = [];

    try {
      const secretsContent = await Deno.readTextFile(secretsPath);
      const secrets = parseEnvFile(secretsContent);
      availableSecrets = Object.keys(secrets);
      logger.info(`Found ${availableSecrets.length} secrets in ${secretsPath}`);
    } catch {
      logger.warn(`Could not read ${secretsPath}, using template defaults`);
    }

    // Filter secrets to only include production-relevant ones
    const excludedSecrets = [
      "OP_SERVICE_ACCOUNT_TOKEN", // This is for 1Password itself
      "TERRAFORM_BACKEND_ACCESS_KEY_ID", // CI infrastructure
      "TERRAFORM_BACKEND_SECRET_ACCESS_KEY", // CI infrastructure
      "TERRAFORM_BACKEND_ENDPOINT", // CI infrastructure
      "AWS_ACCESS_KEY_ID", // Handled separately
      "AWS_SECRET_ACCESS_KEY", // Handled separately
      "GITHUB_PERSONAL_ACCESS_TOKEN", // Not needed at runtime
      "SSH_PUBLIC_KEY", // Not needed at runtime
      "SSH_PRIVATE_KEY", // Not needed at runtime
      "HETZNER_API_TOKEN", // Infrastructure management only
      "HETZNER_S3_ACCESS_KEY", // Deprecated - use AWS_ACCESS_KEY_ID
      "HETZNER_S3_SECRET_KEY", // Deprecated - use AWS_SECRET_ACCESS_KEY
      "CLOUDFLARE_API_TOKEN", // Infrastructure management only
      "CLOUDFLARE_ZONE_ID", // Infrastructure management only
      "HETZNER_PROJECT_ID", // Infrastructure management only
      "S3_ENDPOINT", // Infrastructure configuration
      "BOLTFOUNDRY_COM_SERVER_IP", // Handled separately as server config
    ];

    const runtimeSecrets = availableSecrets.filter(
      (secret) => !excludedSecrets.includes(secret),
    );

    // Update the env.secret section with discovered secrets
    if (!config.env) {
      config.env = {};
    }
    if (!config.env.clear) {
      config.env.clear = {};
    }

    // Set the secret environment variables
    config.env.secret = runtimeSecrets.length > 0 ? runtimeSecrets : [
      // Fallback to common secrets if .env.secrets doesn't exist
      "DATABASE_URL",
      "ASSEMBLY_AI_KEY",
      "OPEN_AI_API_KEY",
      "OPEN_ROUTER_API_KEY",
      "POSTHOG_API_KEY",
    ];

    // Sort secrets for consistent output
    config.env.secret.sort();

    // Add a comment to track generation
    const header = `# Generated by bft generate-kamal-config
# Template: ${templatePath}
# Generated at: ${new Date().toISOString()}
# Environment: ${environment}
# Secrets count: ${config.env.secret.length}

`;

    // Convert back to YAML
    const outputYaml = header + yaml.stringify(config, {
      lineWidth: -1, // Disable line wrapping
    });

    // Ensure output directory exists
    const outputDir = path.dirname(outputPath);
    await Deno.mkdir(outputDir, { recursive: true });

    // Write the generated config
    await Deno.writeTextFile(outputPath, outputYaml);

    logger.info(`âœ… Generated Kamal config at ${outputPath}`);
    logger.info(`   Included ${config.env.secret.length} runtime secrets`);

    return 0;
  } catch (error) {
    logger.error(`Failed to generate Kamal config: ${error}`);
    return 1;
  }
}

// When run directly as a script
if (import.meta.main) {
  const scriptArgs = Deno.args.slice(2); // Skip "run" and script name
  Deno.exit(await generateKamalConfig(scriptArgs));
}
